# Team Rython: Dainius Masiliunas and Tim Weerman
# Date: January 2016
# License: Apache License 2.0

# Geoscripting project: a comparison between official statistics about forest coverage
# and calculated LAI trends since 2002 in Lithuania

library(bfastSpatial)
library(parallel)
library(lattice)
library(htmlwidgets)

source("src/bfastSpatialHelpers.r") # Generate* functions
source("src/ImportStatistics.r")
source("src/SanitiseNames.r")
source("src/ExtractWithinBorders.r")
source("src/MakePlotSVGs.r")
source("src/GetMunicipalityLeaflet.r")

## MAKE SURE TO SET THE RIGHT WORKING DIRECTORY ##
getwd()

## Data processing ##

# Using LAI data product from the MODIS satellite.
# Get the data (URL script was generated by the MODIS website)
filelist = read.table("data/data_url_script_2016-01-15_032836.txt", as.is=TRUE)
for(url in unlist(filelist))
    download.file(url, destfile=paste0("data/", basename(url)), method="wget")

# Magic numbers!
# QC_val/filtermask: 0x00 means keep everything, 0xFF means keep only if all are 0
# https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd15a2
# http://www.binaryhexconverter.com/binary-to-hex-converter
filtermask = 0x8C # Filter for dead detectors, clouds, and non-produced pixels
fillnumber = 249:255 # From the manual

# Process all the data: remove unreliable pixels
processMODISbatch("data", pattern=glob2rx("*.hdf"), 2, 3, bit=TRUE, QC_val=0x8C, fill=249:255, outdir="data/processed", mc.cores=4)

# Stack resulting layers
Stack = GenerateTimeStack(filename=file.path("data", "processed", "Stack.grd"), x="data/processed", pattern=glob2rx("*.tif"))

# Create annual summary statistics: mean, median, 3rd quartile, max
# These are not in a loop, because it takes a LONG time to calculate each step!
years = 2002:2015
AnnualMed = GenerateAnnualSummary("data/yearly/AnnualMedian.grd", median, dates=getMODISinfo(names(Stack))$date)
names(AnnualMed) = years
AnnualAvg = GenerateAnnualSummary("data/yearly/AnnualAverage.grd", mean, dates=getMODISinfo(names(Stack))$date)
names(AnnualAvg) = years
quartile3 = function(...) quantile(..., probs=c(0.75))[[1]]
AnnualQrt75 = GenerateAnnualSummary("data/yearly/AnnualQuartile75.grd", quartile3, dates=getMODISinfo(names(Stack))$date)
names(AnnualQrt75) = years
quantile90 = function(...) quantile(..., probs=c(0.90))[[1]]
AnnualQnt90 = GenerateAnnualSummary("data/yearly/AnnualQuantile90.grd", quantile90, dates=getMODISinfo(names(Stack))$date)
names(AnnualQnt90) = years
AnnualMax = GenerateAnnualSummary("data/yearly/AnnualMax.grd", max, dates=getMODISinfo(names(Stack))$date)
names(AnnualMax) = years

# Alternatively, this can be run in parallel, one statistic per core; uncomment this block for that:
#tasklist = list(
#    annualMed <- function() annualSummary(s, fun=median, na.rm=TRUE, filename="data/yearly/AnnualMedian.grd", progress="text"),
#    annualAvg <- function() annualSummary(s, fun=mean, na.rm=TRUE, filename="data/yearly/AnnualAverage.grd", progress="text"),
#    annualQrt75 <- function() annualSummary(s, fun=quartile3, na.rm=TRUE, filename="data/yearly/AnnualQuartile75.grd", progress="text"),
#    annualMax <- function() annualSummary(s, fun=max, na.rm=TRUE, filename="data/yearly/AnnualMax.grd", progress="text")
#)
#system.time(stats <- mclapply(tasklist, function(f) f(), mc.cores = 4))

# Create a base raster to render
Summary = summaryBrick(Stack, fun=mean)

## Merging of different data sources ##

# Load administrative borders (note: poor quality and outdated!)
LTU0 = getData("GADM", country="LTU", path="data", level=0)
LTU2 = getData("GADM", country="LTU", path="data", level=2)

# Extract data from all our annual summary statistic layers at both levels
StatRasters = c(AnnualAvg, AnnualMed, AnnualQrt75, AnnualQnt90, AnnualMax) # If you just want to load the data from CSVs, replace with StatRasters = 1:5
StatColNames = c("LAI_Avg", "LAI_Med", "LAI_Q75", "LAI_Q90", "LAI_Max")
AdmData = c(LTU0, LTU2)
AdmPostfix = c("LT", "Mun")
AdmNames = list(c("Republic of Lithuania"), SanitiseNames(LTU2@data$VARNAME_2))
rm(LAIData)
for (n in 1:length(AdmData))
{
    for (i in 1:length(StatRasters))
    {
        # Extract the data from our statistic raster
        Extracted = ExtractWithinBorders(StatRasters[[i]], AdmData[[n]], StatColNames[i], years, ids=AdmNames[[n]],
            filename=paste("output/dataframes/", StatColNames[i], "_", AdmPostfix[n], ".csv", sep=""))
        # Merge into one long data frame
        if (!exists("StatData"))
            StatData = Extracted
        else
            StatData = merge(StatData, Extracted)
    }
    # Merge data frames from the two different levels
    if (!exists("LAIData"))
        LAIData = StatData
    else
        LAIData = rbind(LAIData, StatData)
    rm(StatData, Extracted)
}

# Read statistics from the government
statistics = ImportStatistics()

# Merge the two data frames into one
Dataset = merge(LAIData, statistics, by=c("Municipality", "Year"))
write.table(Dataset, file="output/dataframes/Dataset.csv")

## Generate plots ##

svgdir = file.path("output", "SVG")
MakePlotSVGs(Dataset, svgdir)

## Generate a Leaflet HTML ##

htmldir = file.path(getwd(), "output", "html")
Leaflet = GetMunicipalityLeaflet(LTU0, LTU2, svgdir)
saveWidget(Leaflet, file=file.path(htmldir, "Municipalities.html"), selfcontained=FALSE)

## Done. ##
## Note: Leaflet is a bit silly with popup widths; manually fix that by injecting CSS (optional) ##
wd = getwd()
setwd(htmldir)
system("./addcss.sh")
system("firefox Municipalities.html")
setwd(wd)
